"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var query_exports = {};
__export(query_exports, {
  MsSqlQuery: () => MsSqlQuery
});
module.exports = __toCommonJS(query_exports);
var import_core = require("@sequelize/core");
var import_logger = require("@sequelize/core/_non-semver-use-at-your-own-risk_/utils/logger.js");
var import_forOwn = __toESM(require("lodash/forOwn"));
var import_zipObject = __toESM(require("lodash/zipObject"));
var import_tedious = require("tedious");
var import_symbols = require("./_internal/symbols.js");
const debug = import_logger.logger.debugContext("sql:mssql");
const minSafeIntegerAsBigInt = BigInt(Number.MIN_SAFE_INTEGER);
const maxSafeIntegerAsBigInt = BigInt(Number.MAX_SAFE_INTEGER);
function getScale(aNum) {
  if (!Number.isFinite(aNum)) {
    return 0;
  }
  let e = 1;
  while (Math.round(aNum * e) / e !== aNum) {
    e *= 10;
  }
  return Math.log10(e);
}
class MsSqlQuery extends import_core.AbstractQuery {
  getInsertIdField() {
    return "id";
  }
  getSQLTypeFromJsType(value, TYPES2) {
    const paramType = { type: TYPES2.NVarChar, typeOptions: {}, value };
    if (typeof value === "number") {
      if (Number.isInteger(value)) {
        if (value >= -2147483648 && value <= 2147483647) {
          paramType.type = TYPES2.Int;
        } else {
          paramType.type = TYPES2.BigInt;
        }
      } else {
        paramType.type = TYPES2.Numeric;
        paramType.typeOptions = { precision: 30, scale: getScale(value) };
      }
    } else if (typeof value === "bigint") {
      if (value < minSafeIntegerAsBigInt || value > maxSafeIntegerAsBigInt) {
        paramType.type = TYPES2.VarChar;
        paramType.value = value.toString();
      } else {
        return this.getSQLTypeFromJsType(Number(value), TYPES2);
      }
    } else if (typeof value === "boolean") {
      paramType.type = TYPES2.Bit;
    }
    if (Buffer.isBuffer(value)) {
      paramType.type = TYPES2.VarBinary;
    }
    return paramType;
  }
  async _run(connection, sql, parameters) {
    this.sql = sql;
    const complete = this._logQuery(sql, debug, parameters);
    const query = new Promise((resolve, reject) => {
      const rows2 = [];
      const request = new import_tedious.Request(sql, (err, rowCount2) => {
        err ? reject(err) : resolve([rows2, rowCount2]);
      });
      if (parameters) {
        if (Array.isArray(parameters)) {
          for (let i = 0; i < parameters.length; i++) {
            const paramType = this.getSQLTypeFromJsType(parameters[i], import_tedious.TYPES);
            request.addParameter(
              String(i + 1),
              paramType.type,
              paramType.value,
              paramType.typeOptions
            );
          }
        } else {
          (0, import_forOwn.default)(parameters, (parameter, parameterName) => {
            const paramType = this.getSQLTypeFromJsType(parameter, import_tedious.TYPES);
            request.addParameter(
              parameterName,
              paramType.type,
              paramType.value,
              paramType.typeOptions
            );
          });
        }
      }
      request.on("row", (columns) => {
        rows2.push(columns);
      });
      connection.execSql(request);
    });
    let rows;
    let rowCount;
    try {
      [rows, rowCount] = await query;
    } catch (error) {
      error.sql = sql;
      error.parameters = parameters;
      throw this.formatError(error);
    }
    complete();
    if (Array.isArray(rows)) {
      const dialect = this.sequelize.dialect;
      rows = rows.map((columns) => {
        const row = {};
        for (const column of columns) {
          const parser = dialect.getParserForDatabaseDataType(column.metadata.type.type);
          let value = column.value;
          if (value != null && parser) {
            value = parser(value);
          }
          row[column.metadata.colName] = value;
        }
        return row;
      });
    }
    return this.formatResults(rows, rowCount);
  }
  run(sql, parameters) {
    return this.connection[import_symbols.ASYNC_QUEUE].enqueue(() => this._run(this.connection, sql, parameters));
  }
  /**
   * High level function that handles the results of a query execution.
   *
   * @param {Array} data - The result of the query execution.
   * @param {number} rowCount
   * @private
   * @example
   * Example:
   *  query.formatResults([
   *    {
   *      id: 1,              // this is from the main table
   *      attr2: 'snafu',     // this is from the main table
   *      Tasks.id: 1,        // this is from the associated table
   *      Tasks.title: 'task' // this is from the associated table
   *    }
   *  ])
   */
  formatResults(data, rowCount) {
    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery()) {
      if (this.instance && this.instance.dataValues) {
        if (this.isInsertQuery() && !this.isUpsertQuery() && data.length === 0) {
          throw new import_core.EmptyResultError();
        }
        if (this.isUpsertQuery() && data.length === 0) {
          return [this.instance || data, false];
        }
        if (Array.isArray(data) && data[0]) {
          for (const attributeOrColumnName of Object.keys(data[0])) {
            const modelDefinition = this.model.modelDefinition;
            const attribute = modelDefinition.columns.get(attributeOrColumnName);
            const updatedValue = this._parseDatabaseValue(
              data[0][attributeOrColumnName],
              attribute?.type
            );
            this.instance.set(attribute?.attributeName ?? attributeOrColumnName, updatedValue, {
              raw: true,
              comesFromDatabase: true
            });
          }
        }
      }
      if (this.isUpsertQuery()) {
        return [this.instance || data, data[0].$action === "INSERT"];
      }
      return [
        this.instance || data && (this.options.plain && data[0] || data) || void 0,
        rowCount
      ];
    }
    if (this.isDescribeQuery()) {
      const result = {};
      for (const _result of data) {
        if (_result.Default) {
          _result.Default = _result.Default.replace("('", "").replace("')", "").replaceAll("'", "");
        }
        result[_result.Name] = {
          type: _result.Type.toUpperCase(),
          allowNull: _result.IsNull === "YES",
          defaultValue: _result.Default,
          primaryKey: _result.Constraint === "PRIMARY KEY",
          autoIncrement: _result.IsIdentity === 1,
          comment: _result.Comment
        };
        if (result[_result.Name].type.includes("CHAR") && _result.Length) {
          if (_result.Length === -1) {
            result[_result.Name].type += "(MAX)";
          } else {
            result[_result.Name].type += `(${_result.Length})`;
          }
        }
      }
      return result;
    }
    if (this.isSelectQuery()) {
      return this.handleSelectQuery(data);
    }
    if (this.isShowIndexesQuery()) {
      return this.handleShowIndexesQuery(data);
    }
    if (this.isCallQuery()) {
      return data[0];
    }
    if (this.isBulkUpdateQuery()) {
      return this.options.returning ? this.handleSelectQuery(data) : rowCount;
    }
    if (this.isDeleteQuery()) {
      return data[0] ? data[0].AFFECTEDROWS : 0;
    }
    if (this.isShowConstraintsQuery()) {
      return data;
    }
    if (this.isRawQuery()) {
      return [data, rowCount];
    }
    return data;
  }
  formatError(err) {
    let match;
    match = err.message.match(
      /Violation of (?:UNIQUE|PRIMARY) KEY constraint '([^']*)'\. Cannot insert duplicate key in object '.*'\.(:? The duplicate key value is \((.*)\).)?/s
    );
    match ||= err.message.match(
      /Cannot insert duplicate key row in object .* with unique index '(.*)'\.(:? The duplicate key value is \((.*)\).)?/s
    );
    if (match && match.length > 1) {
      let fields = {};
      const uniqueKey = this.model && this.model.getIndexes().find((index) => index.unique && index.name === match[1]);
      let message = "Validation error";
      if (uniqueKey && Boolean(uniqueKey.msg)) {
        message = uniqueKey.msg;
      }
      if (match[3]) {
        const values = match[3].split(",").map((part) => part.trim());
        if (uniqueKey) {
          fields = (0, import_zipObject.default)(uniqueKey.fields, values);
        } else {
          fields[match[1]] = match[3];
        }
      }
      const errors = [];
      (0, import_forOwn.default)(fields, (value, field) => {
        errors.push(
          new import_core.ValidationErrorItem(
            this.getUniqueConstraintErrorMessage(field),
            "unique violation",
            // ValidationErrorItem.Origins.DB,
            field,
            value,
            this.instance,
            "not_unique"
          )
        );
      });
      const uniqueConstraintError = new import_core.UniqueConstraintError({
        message,
        errors,
        cause: err,
        fields
      });
      if (err.errors?.length > 0) {
        return new import_core.AggregateError([...err.errors, uniqueConstraintError]);
      }
      return uniqueConstraintError;
    }
    match = err.message.match(
      /The (?:DELETE|INSERT|MERGE|UPDATE) statement conflicted with the (?:FOREIGN KEY|REFERENCE) constraint "(.*)"\. The conflict occurred in database "(.*)", table "(.*)", column '(.*)'\./
    );
    if (match && match.length > 1) {
      const fkConstraintError = new import_core.ForeignKeyConstraintError({
        index: match[1],
        cause: err,
        table: match[3],
        fields: [match[4]]
      });
      if (err.errors?.length > 0) {
        return new import_core.AggregateError([...err.errors, fkConstraintError]);
      }
      return fkConstraintError;
    }
    if (err.errors?.length > 0) {
      let firstError;
      for (const [index, error] of err.errors.entries()) {
        match = error.message.match(
          /Could not (?:create|drop) constraint(?: or index)?\. See previous errors\./
        );
        if (match && match.length > 0) {
          let constraint = err.sql.match(/(?:constraint|index) \[(.+?)]/i);
          constraint = constraint ? constraint[1] : void 0;
          let table = err.sql.match(/table \[(.+?)]/i);
          table = table ? table[1] : void 0;
          firstError = new import_core.UnknownConstraintError({
            message: err.errors[index - 1].message,
            constraint,
            table,
            cause: err
          });
        }
      }
      if (firstError) {
        return new import_core.AggregateError([...err.errors, firstError]);
      }
      return new import_core.AggregateError(err.errors);
    }
    return new import_core.DatabaseError(err);
  }
  isShowOrDescribeQuery() {
    let result = false;
    result ||= this.sql.toLowerCase().startsWith(
      "select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'"
    );
    result ||= this.sql.toLowerCase().startsWith("select tablename = t.name, name = ind.name,");
    result ||= this.sql.toLowerCase().startsWith("exec sys.sp_helpindex @objname");
    return result;
  }
  handleShowIndexesQuery(data) {
    const indexes = data.reduce((acc, curr) => {
      if (acc.has(curr.index_name)) {
        const index = acc.get(curr.index_name);
        if (curr.is_included_column) {
          index.includes.push(curr.column_name);
        } else {
          index.fields.push({
            attribute: curr.column_name,
            length: void 0,
            order: curr.is_descending_key ? "DESC" : "ASC",
            collate: void 0
          });
        }
        return acc;
      }
      acc.set(curr.index_name, {
        primary: curr.is_primary_key,
        fields: curr.is_included_column ? [] : [
          {
            attribute: curr.column_name,
            length: void 0,
            order: curr.is_descending_key ? "DESC" : "ASC",
            collate: void 0
          }
        ],
        includes: curr.is_included_column ? [curr.column_name] : [],
        name: curr.index_name,
        tableName: void 0,
        unique: curr.is_unique,
        type: null
      });
      return acc;
    }, /* @__PURE__ */ new Map());
    return Array.from(indexes.values());
  }
}
//# sourceMappingURL=query.js.map
