"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var connection_manager_exports = {};
__export(connection_manager_exports, {
  MsSqlConnectionManager: () => MsSqlConnectionManager
});
module.exports = __toCommonJS(connection_manager_exports);
var import_core = require("@sequelize/core");
var import_check = require("@sequelize/core/_non-semver-use-at-your-own-risk_/utils/check.js");
var import_logger = require("@sequelize/core/_non-semver-use-at-your-own-risk_/utils/logger.js");
var import_object = require("@sequelize/core/_non-semver-use-at-your-own-risk_/utils/object.js");
var import_utils = require("@sequelize/utils");
var Tedious = __toESM(require("tedious"));
var import_async_queue = require("./_internal/async-queue.js");
var import_connection_options = require("./_internal/connection-options.js");
var import_symbols = require("./_internal/symbols.js");
const debug = import_logger.logger.debugContext("connection:mssql");
const debugTedious = import_logger.logger.debugContext("connection:mssql:tedious");
class MsSqlConnectionManager extends import_core.AbstractConnectionManager {
  #lib;
  constructor(dialect) {
    super(dialect);
    this.#lib = dialect.options.tediousModule ?? Tedious;
  }
  async connect(connectionOptions) {
    const [inlinedOptions, regularOptions] = (0, import_utils.splitObject)(connectionOptions, import_connection_options.INLINED_OPTION_NAMES);
    const tediousConfig = {
      ...regularOptions,
      options: (0, import_object.removeUndefined)(inlinedOptions)
    };
    try {
      return await new Promise((resolve, reject) => {
        const connection = new this.#lib.Connection(
          tediousConfig
        );
        if (connection.state === connection.STATE.INITIALIZED) {
          connection.connect();
        }
        connection[import_symbols.ASYNC_QUEUE] = new import_async_queue.AsyncQueue();
        const connectHandler = (error) => {
          connection.removeListener("end", endHandler);
          connection.removeListener("error", errorHandler);
          if (error) {
            return void reject(error);
          }
          debug("connection acquired");
          resolve(connection);
        };
        const endHandler = () => {
          connection.removeListener("connect", connectHandler);
          connection.removeListener("error", errorHandler);
          reject(new Error("Connection was closed by remote server"));
        };
        const errorHandler = (error) => {
          connection.removeListener("connect", connectHandler);
          connection.removeListener("end", endHandler);
          reject(error);
        };
        connection.once("error", errorHandler);
        connection.once("end", endHandler);
        connection.once("connect", connectHandler);
        connection.on("error", (error) => {
          if ((0, import_check.isErrorWithStringCode)(error) && (error.code === "ESOCKET" || error.code === "ECONNRESET")) {
            void this.sequelize.pool.destroy(connection);
          }
        });
        if (tediousConfig.options?.debug) {
          connection.on("debug", debugTedious.log.bind(debugTedious));
        }
      });
    } catch (error) {
      import_utils.isError.assert(error);
      if (!(0, import_check.isErrorWithStringCode)(error)) {
        throw new import_core.ConnectionError(error);
      }
      switch (error.code) {
        case "ESOCKET":
          if (error.message.includes("connect EHOSTUNREACH")) {
            throw new import_core.HostNotReachableError(error);
          }
          if (error.message.includes("connect ENETUNREACH")) {
            throw new import_core.HostNotReachableError(error);
          }
          if (error.message.includes("connect EADDRNOTAVAIL")) {
            throw new import_core.HostNotReachableError(error);
          }
          if (error.message.includes("getaddrinfo ENOTFOUND")) {
            throw new import_core.HostNotFoundError(error);
          }
          if (error.message.includes("connect ECONNREFUSED")) {
            throw new import_core.ConnectionRefusedError(error);
          }
          throw new import_core.ConnectionError(error);
        case "ER_ACCESS_DENIED_ERROR":
        case "ELOGIN":
          throw new import_core.AccessDeniedError(error);
        case "EINVAL":
          throw new import_core.InvalidConnectionError(error);
        default:
          throw new import_core.ConnectionError(error);
      }
    }
  }
  async disconnect(connection) {
    if (connection.closed) {
      return;
    }
    connection[import_symbols.ASYNC_QUEUE].close();
    await new Promise((resolve) => {
      connection.on("end", resolve);
      connection.close();
      debug("connection closed");
    });
  }
  validate(connection) {
    return connection?.state.name === "LoggedIn";
  }
}
//# sourceMappingURL=connection-manager.js.map
